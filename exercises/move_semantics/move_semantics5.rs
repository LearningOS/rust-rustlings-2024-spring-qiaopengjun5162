// move_semantics5.rs
//
// Make me compile only by reordering the lines in `main()`, but without adding,
// changing or removing any of them.
//
// Execute `rustlings hint move_semantics5` or use the `hint` watch subcommand
// for a hint.

fn main() {
    let mut x = 100;
    let y = &mut x;
    *y += 100;
    let z = &mut x;

    *z += 1000;
    assert_eq!(x, 1200);
}

/*
这段Rust代码的实现原理、用途和注意事项如下：

实现原理：
1. 首先，定义了一个可变变量x，并将其初始化为100。
2. 接着，创建了一个可变引用y，它指向变量x。
3. 通过解引用y并加上100，将变量x的值增加100。
4. 然后，创建了另一个可变引用z，它也指向变量x。
5. 通过解引用z并加上1000，将变量x的值增加1000。
6. 最后，使用assert_eq!宏来检查变量x的值是否等于1200。

用途：
这段代码主要用于演示Rust中的可变引用和不可变引用的使用方法。通过使用可变引用，可以在不改变变量本身的情况下修改其值。

注意事项：
1. 在使用可变引用时，需要确保始终使用相同类型的可变引用，否则可能会导致编译错误。
2. 在使用可变引用时，需要确保始终使用相同类型的可变引用，否则可能会导致运行时错误。
3. 在使用可变引用时，需要确保始终使用相同类型的可变引用，否则可能会导致运行时错误。
4. 在使用可变引用时，需要确保始终使用相同类型的可变引用，否则可能会导致运行时错误。
5. 在使用可变引用时，需要确保始终使用相同类型的可变引用，否则可能会导致运行时错误。

总之，这段代码的主要目的是为了演示Rust中的可变引用和不可变引用的使用方法，以及它们之间的区别。




*/
